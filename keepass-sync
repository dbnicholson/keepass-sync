#!/usr/bin/python3

from configparser import ConfigParser
from contextlib import contextmanager
from datetime import datetime
from email.utils import parsedate
from enum import Enum
import gi
import logging
import os
import requests
import sys

gi.require_version('Notify', '0.7')
from gi.repository import GLib, Gio, Notify  # noqa: E402

progname = os.path.basename(sys.argv[0])
logger = logging.getLogger(progname)


class SyncStatus(Enum):
    IN_SYNC = 1
    LOCAL_UPDATE = 2
    REMOTE_UPDATE = 3


def remote_info(session, settings):
    resp = session.head(settings['remote_url'])
    resp.raise_for_status()
    return resp


def remote_download(session, settings):
    resp = session.get(settings['remote_url'])
    resp.raise_for_status()
    return resp


def sync_status(session, settings):
    resp = session.head(settings['remote_url'])
    resp.raise_for_status()
    remote_mtime = datetime(*parsedate(resp.headers['Last-Modified'])[0:6])
    remote_size = int(resp.headers['Content-Length'])
    logger.info('Remote mtime: %s', remote_mtime)
    logger.info('Remote size: %i', remote_size)

    local_stat = os.stat(settings['local_path'])
    local_mtime = datetime.utcfromtimestamp(int(local_stat.st_mtime))
    local_size = local_stat.st_size
    logger.info('Local mtime: %s', local_mtime)
    logger.info('Local size: %i', local_size)

    if local_mtime <= remote_mtime:
        if local_size == remote_size:
            return SyncStatus.IN_SYNC
        else:
            return SyncStatus.LOCAL_UPDATE
    else:
        return SyncStatus.REMOTE_UPDATE


def sync_local(session, settings):
    logger.info('Local database needs update from remote')
    notification = Notify.Notification.new(
        'Local keepass database needs update')
    notification.show()


def sync_remote(session, settings):
    with open(settings['local_path'], 'rb') as f:
        resp = session.put(settings['remote_url'], f)
    resp.raise_for_status()
    logger.info('Remote database updated from local')
    notification = Notify.Notification.new(
        'Remote keepass database updated')
    notification.show()


@contextmanager
def sync_session(settings):
    with requests.Session() as session:
        session.auth = (settings['remote_user'],
                        settings['remote_password'])
        yield session


def sync(settings):
    with sync_session(settings) as session:
        status = sync_status(session, settings)
        logger.info('Sync status: %s', status)
        if status == SyncStatus.LOCAL_UPDATE:
            sync_local(session, settings)
        elif status == SyncStatus.REMOTE_UPDATE:
            sync_remote(session, settings)


def file_changed(monitor, input_file, other_file, event_type, user_data):
    logger.debug('File monitor event received: %s', event_type)
    if event_type in (Gio.FileMonitorEvent.CHANGED,
                      Gio.FileMonitorEvent.CHANGES_DONE_HINT,
                      Gio.FileMonitorEvent.ATTRIBUTE_CHANGED):
        logger.info('Local file changed, syncing')
        sync(user_data)


def main():
    from argparse import ArgumentParser
    aparser = ArgumentParser(description='Sync keepass database to server')
    aparser.add_argument('-w', '--watch', action='store_true',
                         help='Watch for changes to database')
    aparser.add_argument('-i', '--info', action='store_true',
                         help='Show remote file info')
    aparser.add_argument('-d', '--download', help='Download remote file')
    args = aparser.parse_args()

    logging.basicConfig(level=logging.INFO)
    Notify.init(progname)

    config = ConfigParser()
    config.read(os.path.expanduser('~/.config/keepass.ini'))
    keepass_opts = config['keepass']
    settings = {
        'local_path': os.path.expanduser(keepass_opts['local']),
        'remote_url': keepass_opts['remote'],
        'remote_user': keepass_opts['user'],
        'remote_password': keepass_opts['password'],
    }

    if args.info:
        with sync_session(settings) as session:
            resp = remote_info(session, settings)
            for header, value in resp.headers.items():
                print(f'{header}: {value}')
        return

    if args.download:
        with sync_session(settings) as session:
            resp = remote_download(session, settings)
            with open(args.download, 'wb') as f:
                f.write(resp.content)
        return

    sync(settings)

    if args.watch:
        local_file = Gio.File.new_for_path(settings['local_path'])
        local_monitor = Gio.File.monitor(local_file, Gio.FileMonitorFlags.NONE)
        local_monitor.connect('changed', file_changed, settings)

        loop = GLib.MainLoop.new(None, False)
        try:
            loop.run()
        except KeyboardInterrupt:
            pass


if __name__ == '__main__':
    main()
